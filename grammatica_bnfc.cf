--bnfc -m grammatica_bnfc.cf
--make
--./TestGrammaticaBnfc prova_1.c
entrypoints Program ;
 
comment "//" ;
comment "#" ;
comment "/*" "*/" ;

Prog.				Program ::= Decl ;
ListProg.			Program ::= Decl Program;

StmDecl.			Decl ::= Stm ;
FunDecl. 			Decl ::= Function ;

-- Statement

ExpressStm.			Stm ::= RExp ";" ;

SingleVar.			Stm ::= Type Id ";" ;
MulVar.		  		Stm ::= Type Id "," [Id] ";" ;
separator Id "," ;
VarInit.	  		Stm ::= Type Id "=" RExp ";" ;

Const.			  	Stm ::= "const" Type Id "=" RExp ";" ;

Assign.			  	Stm ::= LExp "=" RExp ";" ;
Block.			  	Stm ::= "{" [Stm] "}" ;
IfThen.			  	Stm ::= "if" "(" RExp ")" "{" [Stm] "}" ;
IfThenElse.			Stm ::= "if" "(" RExp ")" "{" [Stm] "}" "else" "{" [Stm] "}" ;
Switch.			  	Stm ::= "switch" "(" RExp ")" "{" [Stm] "}" ;
While.			  	Stm ::= "while" "(" RExp ")" "{" [WhileStm] "}" ;
DoWhile.		  	Stm ::= "do" "{" [WhileStm]  "}" "while" "(" RExp ")" ";" ;
For.			    Stm ::= "for" "(" Init ";" RExp ";" Iter ")" "{" [Stm] "}" ;
InitType.			Init ::= Type Id "=" RExp;
InitAssign.			Init ::= LExp "=" RExp;
IterAss.			Iter ::= LExp "=" RExp;
IterRExp.			Iter ::= RExp;


Return.			  	Stm ::= "return" RExp ";" ;
ReturnOnly.			Stm ::= "return" ";" ;
separator Stm "" ;

FunCall.		    Stm ::= Id "(" [RExp] ")" ";" ;
WriteInt.           Stm ::= "writeInt" "(" [RExp] ")" ";" ;
WriteFloat.         Stm ::= "writeFloat" "(" [RExp] ")" ";" ;
WriteChar.          Stm ::= "writeChar" "(" [RExp] ")" ";" ;
WriteString.        Stm ::= "writeString" "(" [RExp] ")" ";" ;
separator RExp "," ;

Break.				WhileStm ::= "break" ";" ;
Continue.			WhileStm ::= "continue" ";" ;
WhileStatement.		WhileStm ::= Stm ;
separator WhileStm "" ;

FuncDef.			Function ::= "void" Id "(" [Arg] ")" "{" [Stm] "}";
FuncDef1.			Function ::= Type Id "(" [Arg] ")" "{" [Stm] "}";
separator Arg ";" ;
terminator Stm "" ;
ArgDec.				Arg ::= Type Id ";";

-- Espressioni

EOr.				RExp  ::= RExp "||" RExp1 ;
EAnd.			  	RExp1 ::= RExp1 "&&" RExp2 ;
ENot.		  		RExp2 ::= "!" RExp3 ;
NEq.		  		RExp3 ::= RExp3 "==" RExp4 ;
ENEq.		  		RExp3 ::= RExp3 "!=" RExp4 ;
ELt.		  		RExp3 ::= RExp3 "<" RExp4 ;
EGt.		  		RExp3 ::= RExp3 ">" RExp4 ;
ELtEq.				RExp3 ::= RExp3 "<=" RExp4 ;
EGtEq.				RExp3 ::= RExp3 ">=" RExp4 ;
Eplus.				RExp4 ::= RExp4 "+" RExp5 ;
EMinus.				RExp4 ::= RExp4 "-" RExp5 ;
EDiv.			  	RExp5 ::= RExp5 "/" RExp6 ;
ETimes.				RExp5 ::= RExp5 "*" RExp6 ;
EMod.			  	RExp5 ::= RExp5 "%" RExp5 ;
EIncr.				RExp6 ::= "++" RExp7 ;
EDecr.				RExp6 ::= "--" RExp7 ;
EPIncr.				RExp7 ::= RExp8 "++" ;
EPDecr.				RExp7 ::= RExp8 "--" ;
EPar.			  	RExp8 ::= "(" RExp9 ")" ;
ELExp.				RExp9 ::= LExp ;
EArr.			  	RExp11 ::= "{" [RExp] "}" ;
EFunCall.			RExp12 ::= Id "(" [RExp] ")" ;
EReadInt.           RExp13 ::= "readInt" "(" ")" ;
EReadFloat.         RExp13 ::= "readFloat" "(" ")" ;
EReadChar.          RExp13 ::= "readChar" "(" ")" ;
EReadString.        RExp13 ::= "readString" "(" ")" ;
separator RExp "," ;
ERef.				RExp14 ::=  "&" RExp15 ;
EBool.				RExp15 ::= VBool ;
EInt.			  	RExp15 ::= VInteger ;
EFloat.				RExp15 ::= VDouble ;
EString.            RExp15 ::= VString ;
EChar.              RExp15 ::= VChar ;

coercions RExp 15 ;

-- LEexp

EVex. 				LExp ::= "*" LExp1 ;
EElat.				LExp1 ::= LExp1 "[" RExp "]" ;
EDeref.				LExp2 ::= Id ;

coercions LExp 2 ;

-- Tipi

TArray.				Type ::= Type "[" "]" ;
TarrayLength.		Type ::= Type "[" RExp "]" ;
TBool.			  	Type ::= "bool" ;
TFloat.		     	Type ::= "float" ;
TChar.		  		Type ::= "char" ;
TString.		  	Type ::= "String" ;
TInt.				Type ::= "int" ;
TPointer.			Type ::= FunType "*" ;
TVoid.		  		FunType ::= "void" ;
TFunType.		  	FunType ::= Type ;

-- Token

position token Id ( letter (letter | digit | '_')* ) ;
position token VInteger ( digit+ ) ;
position token VDouble ( digit+ '.' digit+ ) ;
position token VString ( '"' char* '"' ) ;
position token VChar ( '\'' char '\'' ) ;
position token VBool {"true"} | {"false"} ;