
entrypoints Program ;

comment "//" ;
comment "/*" "*/" ;


-- PROGRAM ///////////////////////////////////////////////////

Prog.					Program ::= [Global] ;

FunDecl.				Global ::= FunctionDefinition ;
GlobalDecl.				Global ::= Declaration ";" ;

terminator Global "" ;


-- FUNCTIONS AND PROCEDURES //////////////////////////////////

ProcDef.				FunctionDefinition ::= "void" FunRest ;
FunDef.					FunctionDefinition ::= Qualified_Type FunRest ;

Rest.					FunRest ::= Id "(" [FormalParam] ")" Block ;

FormParam.				FormalParam ::= Qualified_Type Id ;
separator FormalParam "," ;

Blk.					Block ::= "{" [Statement] "}" ;
terminator Statement "" ;


-- STATEMENTS /////////////////////////////////////////////////

StmBlk.					Statement ::= Block ;

StmDecl.				Statement ::= Declaration ";" ;
StmExpAssign.			Statement ::= Exp AssignmentOp Exp ";" ;
StmExp.					Statement ::= Exp ";" ;

StmRet1.				Statement ::= "return" ";" ;
StmRet2.				Statement ::= "return" Exp ";" ;

StmCond.				Statement ::= Conditional ;

CondIf.					Conditional ::= If ;

RuleIf.					If ::= "if" "(" Exp ")" Block RestIf ;
rules RestIf ::= "" | "else" If | "else" Block ;

StmLoop.				Statement ::= Loop ;

LoopWhile.				Loop ::= While ;
LoopDoWhile.			Loop ::= DoWhile ;
LoopFor.				Loop ::= For ;

RuleWhile.				While ::= "while" "(" Exp ")" Block ;
RuleDoWhile.			DoWhile ::= "do" Block "while" "(" Exp ")" ";" ;
RuleFor.				For ::= "for" "(" Declaration ";" Exp ";" Exp ")" Block ;

-- TYPES //////////////////////////////////////////////////////

NoQualifier.			Qualified_Type ::= Type ;
YesQualifier.			Qualified_Type ::= Qualifier Type ;

ConstQualifier.			Qualifier ::= "const" ;

rules Type ::= "bool" | "char" | "int" | "float" | "string" | Type "*" ;



Decl.					Declaration ::= Qualified_Type [Init] ;

NameInit.				Init ::= Id ;
ValueInit.				Init ::= Id "=" Exp ;

separator nonempty Init "," ;



-- EXPRESSIONS ////////////////////////////////////////////////

EXor.					Exp  ::= Exp "^" Exp1 ;
EOr.					Exp1 ::= Exp1 "||" Exp2 ;
EAnd.					Exp2 ::= Exp2 "&&" Exp3 ;
NEq.		  			Exp3 ::= Exp3 "==" Exp4 ;
ENeq.		  			Exp3 ::= Exp3 "!=" Exp4 ;
ELt.		  			Exp3 ::= Exp3 "<" Exp4 ;
EGt.		  			Exp3 ::= Exp3 ">" Exp4 ;
ELeq.					Exp3 ::= Exp3 "<=" Exp4 ;
EGeq.					Exp3 ::= Exp3 ">=" Exp4 ;
Eplus.					Exp4 ::= Exp4 "+" Exp5 ;
EMinus.					Exp4 ::= Exp4 "-" Exp5 ;
EProd.					Exp5 ::= Exp5 "*" Exp6 ;
EDiv.			  		Exp5 ::= Exp5 "/" Exp6 ;
EMod.			  		Exp5 ::= Exp5 "%" Exp6 ;
EIncr.					Exp6 ::= "++" Exp7 ;
EDecr.					Exp6 ::= "--" Exp7 ;
EPIncr.					Exp7 ::= Exp8 "++" ;
EPDecr.					Exp7 ::= Exp8 "--" ;
EArray.					Exp8 ::= Exp9 "[" Exp "]" ;
EFunCall.				Exp9 ::= Id "(" [Exp] ")" ;
EReadInt.           	Exp9 ::= "readInt" "(" ")" ;
EReadFloat.         	Exp9 ::= "readFloat" "(" ")" ;
EReadChar.          	Exp9 ::= "readChar" "(" ")" ;
EReadString.        	Exp9 ::= "readString" "(" ")" ;
EUnary.					Exp10 ::=  UnaryOp Exp11 ;
EIdAccess.				Exp11 ::= Id ;
ELiteral.				Exp12 ::= Literal ;

separator Exp "," ;
coercions Exp 12 ;

rules UnaryOp ::= "&" | "*" | "+" | "-" | "!";

rules AssignmentOp ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=";



rules Literal ::= PBool | PChar | PInt | PFloat | PString ;




position token Id ( letter (letter | digit | '_' )* ) ;
position token PBool {"true"} | {"false"} ;
position token PChar ( '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ) ;
position token PInt ( digit+ ) ;
position token PFloat ( digit+ '.' digit+ ) ;
position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ) ;