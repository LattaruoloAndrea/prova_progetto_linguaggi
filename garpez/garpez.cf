comment "//" ;
comment "/*" "*/" ;

entrypoints Program ;


-- PROGRAM /////////////////////////////////////////////////////////////////////////

Prog.						Program ::= [Global] ;

GlobalDecl.					Global ::= Declaration ;
FunDecl.					Global ::= Function ;

terminator Global "" ;


-- DECLARATIONS ////////////////////////////////////////////////////////////////////

ConstDecl.					Declaration ::= "const" [InitItem] ";" ;
VarDecl.					Declaration ::= Type [DeclItem] ";" ;

InitDecl.					InitItem ::= Id "=" RExp ;
DeclOnly.					DeclId ::= Id ;
rules DeclItem ::= DeclId | InitItem ;

separator nonempty DeclItem "," ;
separator nonempty InitItem "," ;


Fun.						Function ::= "function" RetType FunRest ;
FRest.						FunRest ::= Id "(" [FormalParam] ")" Block ;

Param.						FormalParam ::= PassBy Type Id ;
ValuePass.					PassBy ::= "" ;
RefPass.					PassBy ::= "ref" ;

separator FormalParam "," ;


Blk.						Block ::= "{" [Declaration] [Statement] "}" ;

terminator Declaration "" ;
terminator Statement "" ;


-- STATEMENTS //////////////////////////////////////////////////////////////////////

-- DeclStm.					Statement ::= Declaration;
BlkStm.						Statement ::= Block ;
CallStm.					Statement ::= Id "(" [RExp] ")" ";" ;
AssignStm.					Statement ::= LExp AssignmentOp RExp ";" ;
LExpStm.					Statement ::= LExp ";" ;
CondStm.					Statement ::= Conditional ;
LoopStm.					Statement ::= Loop ;
JmpStm.						Statement ::= Jump ";";


rules Conditional ::= If ;
rules Loop ::= While | DoWhile | For ;
rules Jump ::= Return | Return RExp | Break | Continue ;


-- CONDITIONALS ////////////////////////////////////////////////////////////////////

IfCond.						If ::= "if" "(" RExp ")" Block RestIf ;
rules 						RestIf ::= "" | "else" If | "else" Block ;


-- LOOPS ///////////////////////////////////////////////////////////////////////////

WhileLoop.					While ::= "while" "(" RExp ")" Block ;
DoWhileLoop.				DoWhile ::= "do" Block "while" "(" RExp ")" ";" ;
ForLoop.					For ::= "for" "(" Declaration ";" RExp ";" RExp ")" Block ;


-- EXPRESSIONS /////////////////////////////////////////////////////////////////////

Post.						LExp ::= LExp1 IncDecOp ;
Pre.						LExp1 ::= IncDecOp LExp2 ;
Dereference.				LExp2 ::= "*" LExp3 ;
Reference.					LExp2 ::= "&" LExp3 ;
ArrayAccess.				LExp3 ::= LExp3 "[" RExp "]" ;
IdExp.						LExp4 ::= Id ;

coercions LExp 4 ;


LogicalXor.					RExp ::= RExp "^" RExp1 ;
LogicalOr.					RExp1 ::= RExp1 "||" RExp2 ;
LogicalAnd.					RExp2 ::= RExp2 "&&" RExp3 ;
LogicalNot.					RExp3 ::= "!" RExp4 ;
Comparison.					RExp4 ::= RExp4 ComparisonOp RExp5 ;
Positive.					RExp5 ::= "+" RExp6 ;
Negative.					RExp5 ::= "-" RExp6 ;
LRExp.						RExp6 ::= LExp ;
CallExp.					RExp7 ::= Id "(" [RExp] ")" ;
Lit.						RExp8 ::= Literal ;

rules Literal ::= PBool | PChar | PInt | PFloat | PString ;

coercions RExp 8 ;
separator RExp "," ;

-- TYPE ////////////////////////////////////////////////////////////////////////////

SType.						Type ::= SimpleType ;
AType.						Type ::= Type "[" PInt "]" ;
PType.						Type ::= Type "*" ;

SRType.						RetType ::= SimpleType ;
RRType.						RetType ::= Type "*" ;

rules SimpleType ::= "bool" | "char" | "int" | "float" | "string" | "void" ;


-- OPERATORS ///////////////////////////////////////////////////////////////////////

rules AssignmentOp ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" ;
rules ComparisonOp ::= "<" | "<=" | "==" | "!=" | ">=" | ">" ;
rules IncDecOp ::= "++" | "--" ;


-- TOKENS //////////////////////////////////////////////////////////////////////////

position token Id ( letter (letter | digit | '_' )* ) ;
position token PBool {"true"} | {"false"} ;
position token PChar ( '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ) ;
position token PInt ( digit+ ) ;
position token PFloat ( digit+ '.' digit+ ) ;
position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ) ;

position token Return {"return"} ;
position token Break {"break"} ;
position token Continue {"continue"} ;