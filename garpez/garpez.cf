comment "//" ;
comment "/*" "*/" ;

entrypoints Program ;


-- PROGRAM /////////////////////////////////////////////////////////////////////////

Prog.						Program ::= [Global] ;

GlobalDecl.					Global ::= Declaration ;
FunDecl.					Global ::= Function ;

terminator Global "" ;


-- DECLARATIONS ////////////////////////////////////////////////////////////////////

ConstDecl.					Declaration ::= "const" [InitItem] ";" ;
VarDecl.					Declaration ::= Type [DeclItem] ";" ;

InitDecl.					InitItem ::= Id "=" RExp ;
DeclOnly.					DeclId ::= Id ;
rules DeclItem ::= DeclId | InitItem ;

separator nonempty DeclItem "," ;
separator nonempty InitItem "," ;


Fun.						Function ::= "function" RetType FunRest ;
FRest.						FunRest ::= Id "(" [FormalParam] ")" Block ;

Param.						FormalParam ::= PassBy Type Id ;
ValuePass.					PassBy ::= "" ;
RefPass.					PassBy ::= "ref" ;

separator FormalParam "," ;


Blk.						Block ::= "{" [Declaration] [Statement] "}" ;

terminator Declaration "" ;
terminator Statement "" ;


-- STATEMENTS //////////////////////////////////////////////////////////////////////

-- DeclStm.					Statement ::= Declaration;
BlkStm.						Statement ::= Block ;
CallStm.					Statement ::= Id "(" [RExp] ")" ";" ;
AssignStm.					Statement ::= LExp AssignmentOp RExp ";" ;
LExpStm.					Statement ::= LExp ";" ;
CondStm.					Statement ::= Conditional ;
LoopStm.					Statement ::= Loop ;
JmpStm.						Statement ::= Jump ";";
WriteStm.					Statement ::= WPredefined "(" RExp ")" ";" ;


rules Conditional ::= If ;
rules Loop ::= While | DoWhile | For ;
rules Jump ::= Return | Return RExp | Break | Continue ;
rules WPredefined ::= WChar | WInt | WFloat | WString ;


-- CONDITIONALS ////////////////////////////////////////////////////////////////////

IfCond.						If ::= "if" "(" RExp ")" Block RestIf ;
rules 						RestIf ::= "" | "else" If | "else" Block ;


-- LOOPS ///////////////////////////////////////////////////////////////////////////

WhileLoop.					While ::= "while" "(" RExp ")" Block ;
DoWhileLoop.				DoWhile ::= "do" Block "while" "(" RExp ")" ";" ;
ForLoop.					For ::= "for" "(" Declaration ";" RExp ";" RExp ")" Block ;


-- EXPRESSIONS /////////////////////////////////////////////////////////////////////


Dereference.				LExp ::= "*" LExp1 ;
Reference.					LExp1 ::= "&" LExp2 ;
Post.						LExp2 ::= LExp3 IncDecOp ;
Pre.						LExp2 ::= IncDecOp LExp3 ;
ArrayAccess.				LExp3 ::= LExp3 "[" RExp "]" ;
IdExp.						LExp4 ::= Id ;

coercions LExp 4 ;


LogicalOr.					RExp ::= RExp "||" RExp1 ;
LogicalAnd.					RExp1 ::= RExp1 "&&" RExp2 ;
LogicalNot.         RExp2 ::= "!" RExp3 ;
Comparison.					RExp3 ::= RExp3 ComparisonOp RExp4 ;
Sum.						RExp4 ::= RExp4 "+" RExp5 ;
Sub.						RExp4 ::= RExp4 "-" RExp5 ;
Mul.						RExp5 ::= RExp5 "*" RExp6 ;
Div.						RExp5 ::= RExp5 "/" RExp6 ;
Mod.						RExp5 ::= RExp5 "%" RExp6 ;
LogicalXor.					RExp6 ::= RExp6 "^" RExp7 ;
Unary.						RExp7 ::= UnaryOp RExp8 ;
LRExp.						RExp8 ::= LExp ;
CallExp.					RExp9 ::= Id "(" [RExp] ")" ;
ReadExp.					RExp9 ::= RPredefined "(" ")" ;
Lit.						RExp10 ::= Literal ;

rules Literal ::= PBool | PChar | PInt | PFloat | PString ;
rules RPredefined ::= RChar | RInt | RFloat | RString ;

coercions RExp 10 ;
separator RExp "," ;

-- TYPE ////////////////////////////////////////////////////////////////////////////

SType.						Type ::= SimpleType ;
AType.						Type ::= Type "[" PInt "]" ;
PType.						Type ::= Type "*" ;

SRType.						RetType ::= SimpleType ;
RRType.						RetType ::= Type "*" ;

rules SimpleType ::= "bool" | "char" | "int" | "float" | "string" | "void" ;


-- OPERATORS ///////////////////////////////////////////////////////////////////////

rules AssignmentOp ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" ;
rules ComparisonOp ::= "<" | "<=" | "==" | "!=" | ">=" | ">" ;
rules IncDecOp ::= "++" | "--" ;
rules UnaryOp ::= "+" | "-" ;


-- TOKENS //////////////////////////////////////////////////////////////////////////

position token Id ( letter (letter | digit | '_' )* ) ;
position token PBool {"true"} | {"false"} ;
position token PChar ( '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ) ;
position token PInt ( digit+ ) ;
position token PFloat ( digit+ '.' digit+ ) ;
position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ) ;

position token Return {"return"} ;
position token Break {"break"} ;
position token Continue {"continue"} ;

position token RChar {"readChar"} ;
position token RInt {"readInt"} ;
position token RFloat {"readFloat"} ;
position token RString {"readString"} ;

position token WChar {"writeChar"} ;
position token WInt {"writeInt"} ;
position token WFloat {"writeFloat"} ;
position token WString {"writeString"} ;
