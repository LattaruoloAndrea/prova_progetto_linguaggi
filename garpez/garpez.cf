
entrypoints Program ;

comment "//" ;
comment "/*" "*/" ;


-- PROGRAM ///////////////////////////////////////////////////

Prog.					Program ::= [Global] ;

FunDecl.				Global ::= FunctionDefinition ;
GlobalDecl.				Global ::= Declaration ";" ;

terminator Global "" ;


-- FUNCTIONS AND PROCEDURES //////////////////////////////////

ProcDef.				FunctionDefinition ::= "void" FunRest ;
FunDef.					FunctionDefinition ::= Qualified_Type FunRest ;

Rest.					FunRest ::= Id "(" [FormalParam] ")" Block ;

FormParam.				FormalParam ::= PassBy Qualified_Type Id ;
separator FormalParam "," ;

Blk.					Block ::= "{" [Statement] "}" ;
terminator Statement "" ;


-- STATEMENTS /////////////////////////////////////////////////

StmBlk.					Statement ::= Block ;

StmDecl.				Statement ::= Declaration ";" ;
StmExp.					Statement ::= RExp ";" ;

StmRet1.				Statement ::= "return" ";" ;
StmRet2.				Statement ::= "return" RExp ";" ;

StmCond.				Statement ::= Conditional ;

CondIf.					Conditional ::= If ;

RuleIf.					If ::= "if" "(" RExp ")" Block RestIf ;
rules					RestIf ::= "" | "else" If | "else" Block ;

StmLoop.				Statement ::= Loop ;

LoopWhile.				Loop ::= While ;
LoopDoWhile.			Loop ::= DoWhile ;
LoopFor.				Loop ::= For ;

RuleWhile.				While ::= "while" "(" RExp ")" LoopBlock ;
RuleDoWhile.			DoWhile ::= "do" LoopBlock "while" "(" RExp ")" ";" ;
RuleFor.				For ::= "for" "(" Declaration ";" RExp ";" RExp ")" Block ;
LoopBlk.				LoopBlock ::= "{" [LoopStm] "}" ;

rules					LoopStm ::= Statement | "break" ";" | "continue" ";" ;
terminator LoopStm "" ;

-- TYPES //////////////////////////////////////////////////////

NoQualifier.			Qualified_Type ::= Type ;
YesQualifier.			Qualified_Type ::= Qualifier Type ;

ConstQualifier.			Qualifier ::= "const" ;

rules					PassBy ::= "" | "ref" | "name";

rules					Type ::= "bool" | "char" | "int" | "float" | "string" | Type "*" | Type "[" RExp "]";



Decl.					Declaration ::= Qualified_Type [Init] ;

NameInit.				Init ::= Id ;
ValueInit.				Init ::= Id "=" RExp ;
ArrayInit.				Init ::= Id "=" "{" [RExp] "}" ;

separator nonempty Init "," ;



-- EXPRESSIONS ////////////////////////////////////////////////

EAssign.				RExp ::= LExp AssignmentOp RExp ;
ELogicalOr.				RExp1 ::= RExp1 "||" RExp2 ;
EXor.					RExp2 ::= RExp2 "^" RExp3 ;
ELogicalAnd.			RExp3 ::= RExp3 "&&" RExp4 ;
ECompare.				RExp4 ::= RExp4 ComparisonOp RExp5 ;
EAdd.					RExp5 ::= RExp5 "+" RExp6 ;
ESub.					RExp5 ::= RExp5 "-" RExp6 ;
EMul.					RExp6 ::= RExp6 "*" RExp7 ;
EDiv.					RExp6 ::= RExp6 "/" RExp7 ;
EMod.					RExp6 ::= RExp6 "%" RExp7 ;
Predef.					RExp7 ::= Predefined ;
EUnary.					RExp8 ::= UnaryOp RExp8 ;
ERLExp.					RExp9 ::= LExp ;
ELiteral.				RExp9 ::= Literal ;

coercions RExp 9 ;
separator RExp "," ;

EPreID.					LExp ::= LExp2 IncDec ;
EPostID.				LExp1 ::= IncDec LExp3 ;
EDeref.					LExp2 ::= "*" LExp4 ;
EArrayAccess.			LExp3 ::= LExp3 "[" [RExp] "]" ;
EFunctionCall.			LExp3 ::= Id "(" [RExp] ")" ;
EId.					LExp4 ::= Id ;

coercions LExp 4 ;

rules					Predefined ::=	"writeInt" "(" RExp ")" | "writeChar" "(" RExp ")" | "writeFloat" "(" RExp ")" | "writeString" "(" RExp ")" | "readInt" "(" ")" | "readChar" "(" ")" | "readFloat" "(" ")" | "readString" "(" ")" ;
rules					UnaryOp ::= "+" | "-" | "!" | "&" ;
rules					AssignmentOp ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=";
rules					ComparisonOp ::= "<" | "<=" | "==" | "!=" | ">=" | ">" ;
rules					IncDec ::= "++" | "--" ;
rules 					Literal ::= PBool | PChar | PInt | PFloat | PString ;


position token Id ( letter (letter | digit | '_' )* ) ;
position token PBool {"true"} | {"false"} ;
position token PChar ( '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ) ;
position token PInt ( digit+ ) ;
position token PFloat ( digit+ '.' digit+ ) ;
position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ) ;
