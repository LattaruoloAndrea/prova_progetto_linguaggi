
entrypoints Program ;

comment "//" ;
comment "/*" "*/" ;


-- PROGRAM ///////////////////////////////////////////////////

Prog.					Program ::= [Global] ;

FunDecl.				Global ::= FunctionDefinition ;
GlobalDecl.				Global ::= Declaration ";" ;

terminator Global "" ;


-- FUNCTIONS AND PROCEDURES //////////////////////////////////

ProcDef.				FunctionDefinition ::= "void" FunRest ;
FunDef.					FunctionDefinition ::= Qualified_Type FunRest ;

Rest.					FunRest ::= Id "(" [FormalParam] ")" Block ;

FormParam.				FormalParam ::= Qualified_Type PassBy Id ;
separator FormalParam "," ;

Blk.					Block ::= "{" [Statement] "}" ;
terminator Statement "" ;


-- STATEMENTS /////////////////////////////////////////////////

StmBlk.					Statement ::= Block ;

StmDecl.				Statement ::= Declaration ";" ;
StmExp.					Statement ::= Exp ";" ;

StmRet1.				Statement ::= "return" ";" ;
StmRet2.				Statement ::= "return" Exp ";" ;

StmCond.				Statement ::= Conditional ;

CondIf.					Conditional ::= If ;

RuleIf.					If ::= "if" "(" Exp ")" Block RestIf ;
rules RestIf ::= "" | "else" If | "else" Block ;

StmLoop.				Statement ::= Loop ;

LoopWhile.				Loop ::= While ;
LoopDoWhile.			Loop ::= DoWhile ;
LoopFor.				Loop ::= For ;

RuleWhile.				While ::= "while" "(" Exp ")" LoopBlock ;
RuleDoWhile.			DoWhile ::= "do" LoopBlock "while" "(" Exp ")" ";" ;
RuleFor.				For ::= "for" "(" Declaration ";" Exp ";" Exp ")" Block ;
LoopBlk.				LoopBlock ::= "{" [LoopStm] "}" ;

rules LoopStm ::= Statement | "break" ";" | "continue" ";" ;
terminator LoopStm "" ;

-- TYPES //////////////////////////////////////////////////////

NoQualifier.			Qualified_Type ::= Type ;
YesQualifier.			Qualified_Type ::= Qualifier Type ;

ConstQualifier.			Qualifier ::= "const" ;

rules					PassBy ::= "" | "ref" | "name";

rules Type ::= "bool" | "char" | "int" | "float" | "string" | Type "*" | Type "[" Exp "]";



Decl.					Declaration ::= Qualified_Type [Init] ;

NameInit.				Init ::= Id ;
ValueInit.				Init ::= Id "=" Exp ;
ArrayInit.				Init ::= Id "=" "{" [Exp] "}" ;

separator nonempty Init "," ;



-- EXPRESSIONS ////////////////////////////////////////////////

EAssign.				Exp  ::= Exp6 AssignmentOp Exp ;
EXor.					Exp1 ::= Exp1 "^" Exp2 ;
EOr.					Exp2 ::= Exp2 "||" Exp3 ;
EAnd.					Exp3 ::= Exp3 "&&" Exp4 ;
NEq.		  			Exp4 ::= Exp4 "==" Exp5 ;
ENeq.		  			Exp4 ::= Exp4 "!=" Exp5 ;
ELt.		  			Exp4 ::= Exp4 "<" Exp5 ;
EGt.		  			Exp4 ::= Exp4 ">" Exp5 ;
ELeq.					Exp4 ::= Exp4 "<=" Exp5 ;
EGeq.					Exp4 ::= Exp4 ">=" Exp5 ;
Eplus.					Exp5 ::= Exp5 "+" Exp6 ;
EMinus.					Exp5 ::= Exp5 "-" Exp6 ;
EProd.					Exp6 ::= Exp6 "*" Exp7 ;
EDiv.			  		Exp6 ::= Exp6 "/" Exp7 ;
EMod.			  		Exp6 ::= Exp6 "%" Exp7 ;
EIncr.					Exp7 ::= "++" Exp8 ;
EDecr.					Exp7 ::= "--" Exp8 ;
EPIncr.					Exp8 ::= Exp9 "++" ;
EPDecr.					Exp8 ::= Exp9 "--" ;
EArray.					Exp9 ::= Exp10 "[" Exp "]" ;
EFunCall.				Exp10 ::= Id "(" [Exp] ")" ;
EReadInt.           	Exp10 ::= "readInt" "(" ")" ;
EReadFloat.         	Exp10 ::= "readFloat" "(" ")" ;
EReadChar.          	Exp10 ::= "readChar" "(" ")" ;
EReadString.        	Exp10 ::= "readString" "(" ")" ;
EWriteInt.           	Exp10 ::= "writeInt" "(" Exp ")" ;
EWriteFloat.         	Exp10 ::= "writeFloat" "(" Exp ")" ;
EWriteChar.          	Exp10 ::= "writeChar" "(" Exp ")" ;
EWriteString.        	Exp10 ::= "writeString" "(" Exp ")" ;
EUnary.					Exp11 ::=  UnaryOp Exp12 ;
EIdAccess.				Exp12 ::= Id ;
ELiteral.				Exp13 ::= Literal ;

separator Exp "," ;
coercions Exp 13 ;

rules UnaryOp ::= "&" | "*" | "+" | "-" | "!";

rules AssignmentOp ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=";



rules Literal ::= PBool | PChar | PInt | PFloat | PString ;




position token Id ( letter (letter | digit | '_' )* ) ;
position token PBool {"true"} | {"false"} ;
position token PChar ( '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ) ;
position token PInt ( digit+ ) ;
position token PFloat ( digit+ '.' digit+ ) ;
position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ) ;
