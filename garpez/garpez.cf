entrypoints Program ;

comment "//" ;
comment "/*" "*/" ;


-- PROGRAM ///////////////////////////////////////////////////

Prog.					Program ::= [Global] ;

FunDecl.				Global ::= FunctionDefinition ;
GlobalDecl.				Global ::= Declaration ";";

terminator Global "" ;


-- FUNCTIONS AND PROCEDURES //////////////////////////////////

ProcDef.				FunctionDefinition ::= "void" FunRest ;
FunDef.					FunctionDefinition ::= Qualified_Type FunRest ;

Rest.					FunRest ::= Id "(" [FormalParam] ")" Block ;

FormParam.				FormalParam ::= Qualified_Type Id ;
separator FormalParam "," ;

Blk.					Block ::= "{" [Statement] "}" ;
terminator Statement ";" ;


-- STATEMENTS /////////////////////////////////////////////////

StmDecl.				Statement ::= Declaration ;
StmLExp.				Statement ::= LExp ;

StmRet1.				Statement ::= "return" ;
StmRet2.				Statement ::= "return" RExp ;


-- TYPES //////////////////////////////////////////////////////

NoQualifier.			Qualified_Type ::= Type ;
YesQualifier.			Qualified_Type ::= Qualifier Type ;

ConstQualifier.			Qualifier ::= "const" ;

rules Type ::= "bool" | "char" | "int" | "float" | "string" ;



Decl.					Declaration ::= Qualified_Type [Init] ;

NameInit.				Init ::= Id ;
ValueInit.				Init ::= Id "=" RExp ;

separator nonempty Init "," ;



-- EXPRESSIONS ////////////////////////////////////////////////

LitExp.					RExp ::= Literal ;



EVex.					LExp ::= "*" LExp1 ;
EElat.					LExp1 ::= LExp1 "[" RExp "]" ;
EDeref.					LExp2 ::= Id ;

coercions LExp 2 ;



rules Literal ::= PBool | PChar | PInt | PFloat | PString ;




position token Id ( letter (letter | digit | '_' )* ) ;
position token PBool {"true"} | {"false"} ;
position token PChar ( '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ) ;
position token PInt ( digit+ ) ;
position token PFloat ( digit+ '.' digit+ ('e' '-'? digit+)? ) ;
position token PString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ) ;