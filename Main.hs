module Main where

import AbsChapel
import TypeChecker
import TCType
import LexChapel
import ParChapel
import AbsChapel
import TCType
import TCInstances
import Locatable
import Env
import Control.Monad (unless, when, mapM_, forM_)
import qualified ErrM as EM
import qualified ErrT as ET
import PrintChapel
import Tac
import TacGenerator

import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )

-- File modified from the one generated by BNFC

type ParseFun a = [Token] -> EM.Err a

myLLexer = myLexer

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: Verbosity -> ParseFun (Program ()) -> FilePath -> IO ()
runFile v p f = do
  putStrLn "=============================================================="
  putStrLn $ "Compiling " ++ f ++ " ...\n"
  code <- readFile f
  run f v p code

run :: FilePath -> Verbosity -> ParseFun (Program ()) -> String -> IO ()
run fpath v p s = let ts = myLLexer s in case p ts of
    EM.Bad s    -> do
        putStrLn "\nParse Failed..."
        putStrLn s
    EM.Ok  tree -> do
        writeSource fpath $ printTree tree
        case typeCheck tree of
            EM.Bad s -> do
                putStrLn "\nTypeCheck Failed..."
                writeErrors fpath s
            EM.Ok prog -> do
                writeTAC fpath $ genTAC prog

writeSource :: FilePath -> String -> IO ()
writeSource fpath s = do
  let fsource = fpath ++ ".source"
  putStrLn $ "Writing source-code in " ++ fsource ++ " ..."
  writeFile fsource s
  putStrLn "Done!\n"

-- Three address code is printed with a newline at each 5 instructions (for better readability)
writeTAC :: FilePath -> [TAC] -> IO ()
writeTAC fpath tac = do
  let ftac = fpath ++ ".tac"
  putStrLn $ "Writing three-address-code in " ++ ftac ++ " ..."
  writeFile ftac $ unlines $ map helper $ zip [1..] $ map show tac
  putStrLn "Done!\n"
  where
    helper (n, t) = if n `mod` 5 == 0
        then t ++ "\n"
        else t

writeErrors :: FilePath -> String -> IO ()
writeErrors fpath errors = do
  let ferr = fpath ++ ".err"
  putStrLn $ "Writing errors in " ++ ferr ++ " ..."
  writeFile ferr errors
  putStrLn "Done!\n"

usage :: IO ()
usage = do
  putStrLn $ "Error usage: please call with a filepath or with 'demo'\n"
  exitFailure

runDemo :: IO ()
runDemo = forM_ fileNames helper
  where
    correctNames = ["test/correct_test_" ++ (show n) ++ ".ch" | n <- [1..5]]
    errorNames   = ["test/error_tc_" ++ (show n) ++ ".ch" | n <- [1..16]]
    fileNames    = correctNames ++ errorNames

    -- helper fpath = putStrLn fpath
    helper fpath = mapM_ (runFile 2 pProgram) [fpath]



main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> usage
    ["--demo"] -> runDemo
    fs -> mapM_ (runFile 2 pProgram) fs