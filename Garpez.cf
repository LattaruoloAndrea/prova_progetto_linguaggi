entrypoints Program ;

comment "//" ;
comment "/*" "*/" ;

-- PROGRAM //////////////////////////////////////////
Progr.              Program ::= [Decl] ;
separator Decl "" ;
terminator Decl "" ;

StmDecl.            Decl ::= Stm ;
DefDecl.            Decl ::= Def ;


-- DEFINITIONS //////////////////////////////////////
DefConst.           Def ::= ConstDef ;
DefVar.             Def ::= VarDef ;
DefFun.             Def ::= FunDef ;


-- CONSTANTS ////////////////////////////////////////
Const.              ConstDef ::= "const" Id "=" RExp ";" ;
ConstList.          ConstDef ::= "const" [ConstDecl] ;
ConstMult.          ConstDecl ::= Id "=" RExp ;

separator ConstDecl "," ;
terminator ConstDecl ";" ;


-- VARIABLES ////////////////////////////////////////
SingleVar.          VarDef ::= Type Id ";" ;
MulVar.             VarDef ::= Type [Id] ;

separator Id "," ;
terminator Id ";" ;

SingleVarInit.      VarDef ::= Type Id "=" RExp ";" ;
MulVarInit.         VarDef ::= Type [VarDecl] ;
VarList.            VarDecl ::= Id "=" RExp ;

separator VarDecl "," ;
terminator VarDecl ";" ;

-- FUNCTIONS/PROCEDURES /////////////////////////////
FuncProc.           FunDef ::= RetType Id "(" [Param] ")" Block ;
ParamDec.              Param ::= PassBy Type Id ;

separator Param "," ;
terminator Param "" ;

PValue.             PassBy ::= "" ;
PReference.         PassBy ::= "ref" ;
PConst.             PassBy ::= "const" ;
PRes.               PassBy ::= "res" ;
PValRes.            PassBy ::= "valres" ;
PName.              PassBy ::= "name" ;

RType.              RetType ::= SimpleType ;
RRef.               RetType ::= "&" Type ;

-- TYPES ////////////////////////////////////////////
TSimple.            Type ::= SimpleType;
TArray.             Type ::= Type "[" "]" ;
TarrayLength.       Type ::= Type "[" RExp "]" ;
TRef.               Type ::= "&" Type ;

TBool.              SimpleType ::= "bool" ;
TFloat.             SimpleType ::= "float" ;
TChar.              SimpleType ::= "char" ;
TString.            SimpleType ::= "string" ;
TInt.               SimpleType ::= "int" ;
TVoid.              SimpleType ::= "void" ;

-- STATEMENTS ///////////////////////////////////////
BlockStm.           Stm ::= Block ;
Call.               Stm ::= Id "(" [RExp] ")" ";" ;

separator RExp "," ;
terminator RExp "" ;

Assignement.        Stm ::= LExp AssignOp RExp ";" ;
LExpStm.            Stm ::= LExp ";" ;
IfStm.              Stm ::= "if" "(" RExp ")" Block ;
IfElseStm.          Stm ::= "if" "(" RExp ")" Block "else" Block ;
WhileStm.           Stm ::= "while" "(" RExp ")" Block ;
DoWhileStm.         Stm ::= "do" Block "while" "(" RExp ")" ";" ;
ForStm.             Stm ::= "for" "(" Init ";" RExp ";" Iter ")" Block ;
InitType.           Init ::= Type Id "=" RExp ;
InitAssign.         Init ::= LExp "=" RExp ;
IterAss.            Iter ::= LExp "=" RExp ;
IterRExp.           Iter ::= RExp ;
BreakStm.           Stm ::= Break ";" ;
ContinueStm.        Stm ::= Continue ";" ;
ReturnStm.          Stm ::= Return ";" ;
ReturnRExpStm.      Stm ::= Return RExp ";" ;
WriteStm.           Stm ::= WritePred ";" ;

WriteInt.           WritePred ::= "writeInt" "(" [RExp] ")" ;
WriteFloat.         WritePred ::= "writeFloat" "(" [RExp] ")" ;
WriteChar.          WritePred ::= "writeChar" "(" [RExp] ")" ;
WriteString.        WritePred ::= "writeString" "(" [RExp] ")" ;
separator RExp "," ;
terminator RExp "" ;

BlockDec.           Block ::= "{" [Def] [Stm] "}" ;
separator Def "" ;
terminator Def "" ;
separator Stm "" ;
terminator Stm "" ;

AssignEq.           AssignOp ::= "=" ;
AssignInc.          AssignOp ::= "+=" ;
AssignDec.          AssignOp ::= "-=" ;
AssignProd.         AssignOp ::= "*=" ;
AssignDiv.          AssignOp ::= "/=" ;
AssignBitXor.       AssignOp ::= "^=" ;
AssignBitAnd.       AssignOp ::= "&=" ;
AssignBitOr.        AssignOp ::= "|=" ;

-- LEXP //////////////////////////////////////////////
Id.                 LExp ::= Id ;
Array.              LExp ::= LExp "[" RExp "]" ;
Deference.          LExp ::= "*" LExp ;
Reference.          LExp ::= "&" LExp ;
PreIncDec.          LExp ::= IncDecOp LExp ;
PostIncDec.         LExp ::= LExp IncDecOp ;
LExpPar.            LExp ::= "(" LExp ")" ;

coercions LExp 5 ;

IncOp.              IncDecOp ::= "++" ;
DecOp.              IncDecOp ::= "--" ;

-- REXP //////////////////////////////////////////////
RExpLExp.           RExp ::= LExp ;
LiteralRExp.        RExp ::= Literal ;
BinaryOp.           RExp ::= RExp BinOp RExp ;
UnaryOp.            RExp ::= UnOp RExp ;
ReadRExp.           RExp ::= ReadPred ;
RExpCall.           RExp ::= Id "(" [RExp] ")" ;
Paren.              RExp ::= "(" RExp ")" ;
separator RExp "," ;
terminator RExp "" ;

ReadInt.           ReadPred ::= "readInt" "(" ")" ;
ReadFloat.         ReadPred ::= "readFloat" "(" ")" ;
ReadChar.          ReadPred ::= "readChar" "(" ")" ;
ReadString.        ReadPred ::= "readString" "(" ")" ;

LiteralBool.        Literal ::= VBool ;
LiteralChar.        Literal ::= VChar ;
LiteralInt.         Literal ::= VInteger ;
LiteralFloat.       Literal ::= VDouble ;
LiteralString.      Literal ::= VString ;

UnOpNot.            UnOp ::= "!" ;
UnOpNeg.            UnOp ::= "-" ;

LogicalOr.          BinOp ::= "||" ;
LogicalAnd.         BinOp ::= "&&" ;
LogicalEq.          BinOp ::= "==" ;
LogicalNeq.         BinOp ::= "!=" ;
LogicalLt.          BinOp ::= "<" ;
LogicalLe.          BinOp ::= "<=" ;
LogicalGt.          BinOp ::= ">" ;
LogicalGe.          BinOp ::= ">=" ;

ArithmSum.          BinOp ::= "+" ;
ArithmDiff.         BinOp ::= "-" ;
ArithmProd.         BinOp ::= "*" ;
ArithmDiv.          BinOp ::= "/" ;
ArithmMod.          BinOp ::= "%" ;
LogicalXor.         BinOp ::= "^" ;

-- TOKENS ////////////////////////////////////////////
position token Id ( letter (letter | digit | '_')* ) ;
position token VInteger ( digit+ ) ;
position token VDouble ( digit+ '.' digit+ ) ;
position token VString ( '"' ((char - ["\"\\"]) | ('\\' ["\"\\nt"]))* '"' ) ;
position token VChar ( '\'' ((char - ["'\\"]) | ('\\' ["'\\nt"])) '\'' ) ;
position token VBool {"true"} | {"false"} ;
position token Break {"break"} ;
position token Continue {"continue"} ;
position token Return {"return"} ;