module SkelGarpezpp where

-- Haskell module generated by the BNF converter

import AbsGarpezpp
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  Prog fdecls -> failure x
transFDecl :: FDecl -> Result
transFDecl x = case x of
  FDecl rtype ident params block -> failure x
transParam :: Param -> Result
transParam x = case x of
  Param type_ passby ident -> failure x
transPassBy :: PassBy -> Result
transPassBy x = case x of
  PassVal -> failure x
  PassRef -> failure x
transDList :: DList -> Result
transDList x = case x of
  VList type_ vdecls -> failure x
  CList cdecls -> failure x
transVDecl :: VDecl -> Result
transVDecl x = case x of
  VSolo ident -> failure x
  VInit ident rexp -> failure x
transCDecl :: CDecl -> Result
transCDecl x = case x of
  CDecl ident rexp -> failure x
transType :: Type -> Result
transType x = case x of
  Type basic compound -> failure x
transCompound :: Compound -> Result
transCompound x = case x of
  Simple -> failure x
  Array compound rexp -> failure x
  Pointer compound -> failure x
transBasic :: Basic -> Result
transBasic x = case x of
  BBool -> failure x
  BChar -> failure x
  BInt -> failure x
  BFloat -> failure x
  BString -> failure x
transRType :: RType -> Result
transRType x = case x of
  RVoid -> failure x
  RBasic basic -> failure x
  RRef type_ -> failure x
transBlock :: Block -> Result
transBlock x = case x of
  Block dlists stms -> failure x
transStm :: Stm -> Result
transStm x = case x of
  StmBlock block -> failure x
  StmCall ident rexps -> failure x
  PredW pwrite rexp -> failure x
  Assign lexp assignop rexp -> failure x
  StmL lexp -> failure x
  If rexp stm -> failure x
  IfElse rexp stm1 stm2 -> failure x
  While rexp stm -> failure x
  DoWhile stm rexp -> failure x
  For ident rexp1 dir rexp2 stm -> failure x
  JmpStm jump -> failure x
transDir :: Dir -> Result
transDir x = case x of
  UpTo -> failure x
  DownTo -> failure x
transJump :: Jump -> Result
transJump x = case x of
  Return -> failure x
  ReturnE rexp -> failure x
  Break -> failure x
  Continue -> failure x
transLExp :: LExp -> Result
transLExp x = case x of
  Deref lexp -> failure x
  Post lexp incdecop -> failure x
  Pre incdecop lexp -> failure x
  Access lexp rexp -> failure x
  Name ident -> failure x
transRExp :: RExp -> Result
transRExp x = case x of
  Or rexp1 rexp2 -> failure x
  And rexp1 rexp2 -> failure x
  Not rexp -> failure x
  Comp rexp1 compop rexp2 -> failure x
  Add rexp1 rexp2 -> failure x
  Sub rexp1 rexp2 -> failure x
  Mul rexp1 rexp2 -> failure x
  Div rexp1 rexp2 -> failure x
  Rem rexp1 rexp2 -> failure x
  Pow rexp1 rexp2 -> failure x
  Sign signop rexp -> failure x
  Ref lexp -> failure x
  RLExp lexp -> failure x
  ArrList rexps -> failure x
  FCall ident rexps -> failure x
  PredR pread -> failure x
  Lit literal -> failure x
transPRead :: PRead -> Result
transPRead x = case x of
  ReadChar -> failure x
  ReadInt -> failure x
  ReadFloat -> failure x
  ReadString -> failure x
transPWrite :: PWrite -> Result
transPWrite x = case x of
  WriteChar -> failure x
  WriteInt -> failure x
  WriteFloat -> failure x
  WriteString -> failure x
transAssignOp :: AssignOp -> Result
transAssignOp x = case x of
  AssignEq -> failure x
  AssignAdd -> failure x
  AssignSub -> failure x
  AssignMul -> failure x
  AssignDiv -> failure x
  AssignMod -> failure x
transCompOp :: CompOp -> Result
transCompOp x = case x of
  Lt -> failure x
  Leq -> failure x
  Eq -> failure x
  Neq -> failure x
  Geq -> failure x
  Gt -> failure x
transIncDecOp :: IncDecOp -> Result
transIncDecOp x = case x of
  Inc -> failure x
  Dec -> failure x
transSignOp :: SignOp -> Result
transSignOp x = case x of
  Pos -> failure x
  Neg -> failure x
transLiteral :: Literal -> Result
transLiteral x = case x of
  LBool boolean -> failure x
  LChar char -> failure x
  LInt integer -> failure x
  LFloat double -> failure x
  LString string -> failure x
transBoolean :: Boolean -> Result
transBoolean x = case x of
  BFalse -> failure x
  BTrue -> failure x

