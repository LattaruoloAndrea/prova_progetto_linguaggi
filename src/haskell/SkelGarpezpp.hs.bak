module SkelGarpezpp where

-- Haskell module generated by the BNF converter

import AbsGarpezpp
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transBoolean :: Boolean -> Result
transBoolean x = case x of
  Boolean string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  Prog fdecls -> failure x
transFDecl :: FDecl -> Result
transFDecl x = case x of
  FDecl rtype ident params block -> failure x
transParam :: Param -> Result
transParam x = case x of
  Param type_ passby ident -> failure x
transPassBy :: PassBy -> Result
transPassBy x = case x of
  PassBy_ -> failure x
  PassBy1 -> failure x
transDList :: DList -> Result
transDList x = case x of
  VList type_ vdecls -> failure x
  CList cdecls -> failure x
transVDecl :: VDecl -> Result
transVDecl x = case x of
  VSolo ident -> failure x
  VInit ident rexp -> failure x
transCDecl :: CDecl -> Result
transCDecl x = case x of
  CDecl ident rexp -> failure x
transType :: Type -> Result
transType x = case x of
  Type basic compound -> failure x
transCompound :: Compound -> Result
transCompound x = case x of
  Simple -> failure x
  Array rexp compound -> failure x
  Pointer compound -> failure x
transBasic :: Basic -> Result
transBasic x = case x of
  Basic_bool -> failure x
  Basic_char -> failure x
  Basic_int -> failure x
  Basic_float -> failure x
  Basic_string -> failure x
transRType :: RType -> Result
transRType x = case x of
  RTypeBasic basic -> failure x
  RType1 type_ -> failure x
transBlock :: Block -> Result
transBlock x = case x of
  Block dlists stms -> failure x
transStm :: Stm -> Result
transStm x = case x of
  StmBlock block -> failure x
  StmCall ident rexps -> failure x
  PredW pwrite rexp -> failure x
  Assign lexp {- assignop -} rexp -> failure x
  StmL lexp -> failure x
  If rexp stm -> failure x
  IfElse rexp stm1 stm2 -> failure x
  While rexp stm -> failure x
  DoWhile stm rexp -> failure x
  For ident rexp1 dir rexp2 stm -> failure x
  JmpStm jump -> failure x
transDir :: Dir -> Result
transDir x = case x of
  UpTo -> failure x
  DownTo -> failure x
transJump :: Jump -> Result
transJump x = case x of
  Jump_return -> failure x
  Jump1 rexp -> failure x
  Jump_break -> failure x
  Jump_continue -> failure x
transLExp :: LExp -> Result
transLExp x = case x of
  Deref lexp -> failure x
  Post lexp incdecop -> failure x
  Pre incdecop lexp -> failure x
  Access lexp rexp -> failure x
  Name ident -> failure x
transRExp :: RExp -> Result
transRExp x = case x of
  Or rexp1 rexp2 -> failure x
  And rexp1 rexp2 -> failure x
  Not rexp -> failure x
  Comp rexp1 compop rexp2 -> failure x
  Add rexp1 rexp2 -> failure x
  Sub rexp1 rexp2 -> failure x
  Mul rexp1 rexp2 -> failure x
  Div rexp1 rexp2 -> failure x
  Rem rexp1 rexp2 -> failure x
  Pow rexp1 rexp2 -> failure x
  Sign signop rexp -> failure x
  Ref lexp -> failure x
  RLExp lexp -> failure x
  FCall ident rexps -> failure x
  PredR pread -> failure x
  Lit literal -> failure x
transPRead :: PRead -> Result
transPRead x = case x of
  PRead_readChar -> failure x
  PRead_readInt -> failure x
  PRead_readFloat -> failure x
  PRead_readString -> failure x
transPWrite :: PWrite -> Result
transPWrite x = case x of
  PWrite_writeChar -> failure x
  PWrite_writeInt -> failure x
  PWrite_writeFloat -> failure x
  PWrite_writeString -> failure x
transAssignOp :: AssignOp -> Result
transAssignOp x = case x of
  AssignOp1 -> failure x
  AssignOp2 -> failure x
  AssignOp3 -> failure x
  AssignOp4 -> failure x
  AssignOp5 -> failure x
  AssignOp6 -> failure x
  AssignOp7 -> failure x
  AssignOp8 -> failure x
  AssignOp9 -> failure x
transCompOp :: CompOp -> Result
transCompOp x = case x of
  CompOp1 -> failure x
  CompOp2 -> failure x
  CompOp3 -> failure x
  CompOp4 -> failure x
  CompOp5 -> failure x
  CompOp6 -> failure x
transIncDecOp :: IncDecOp -> Result
transIncDecOp x = case x of
  IncDecOp1 -> failure x
  IncDecOp2 -> failure x
transSignOp :: SignOp -> Result
transSignOp x = case x of
  SignOp1 -> failure x
  SignOp2 -> failure x
transLiteral :: Literal -> Result
transLiteral x = case x of
  LiteralBoolean boolean -> failure x
  LiteralChar char -> failure x
  LiteralInteger integer -> failure x
  LiteralDouble double -> failure x
  LiteralString string -> failure x

