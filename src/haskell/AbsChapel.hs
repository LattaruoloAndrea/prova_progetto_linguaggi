-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

module AbsChapel where

data Loc = Loc { line, column :: Int }
  deriving (Eq, Ord, Read)

instance Show Loc where
  show l = "(" ++ (show $ line l) ++ "," ++ (show $ column l) ++ ")"

data Ident = Ident {idLoc :: Loc, idName :: String}
  deriving (Eq, Ord, Show, Read)

data Program = Prog [Decl]
  deriving (Eq, Ord, Show, Read)

data Decl
    = FDecl Ident [Form] Intent Type Block
    | VList [VDecl]
    | CList [CDecl]
  deriving (Eq, Ord, Show, Read)

data Form = Form Intent Ident Type
  deriving (Eq, Ord, Show, Read)

data Intent = In | Out | InOut | Ref | ConstIn | ConstRef
  deriving (Eq, Ord, Show, Read)

data VDecl = Solo Ident Type | Init Ident Type RExp
  deriving (Eq, Ord, Show, Read)

data CDecl = CDecl Ident Type RExp
  deriving (Eq, Ord, Show, Read)

data Type = Type Compound Basic
  deriving (Eq, Ord, Show, Read)

data Compound = Simple | Array Compound RExp | Pointer Compound
  deriving (Eq, Ord, Show, Read)

data Basic = BBool | BChar | BInt | BReal | BString | BVoid
  deriving (Eq, Ord, Show, Read)

data Block = Block {bLoc :: Loc, decls :: [Decl], stms :: [Stm]}
  deriving (Eq, Ord, Show, Read)

data Stm
    = StmBlock Block
    | StmCall Ident [RExp]
    | Assign LExp AssignOp RExp
    | StmL LExp
    | If RExp Stm
    | IfElse RExp Stm Stm
    | While RExp Stm
    | DoWhile Stm RExp
    | For Ident Range Stm
    | JmpStm Jump
  deriving (Eq, Ord, Show, Read)

data Jump
  = Return    {jmpLoc :: Loc}
  | ReturnE   {jmpLoc :: Loc, retE :: RExp}
  | Break     {jmpLoc :: Loc}
  | Continue  {jmpLoc :: Loc}
  deriving (Eq, Ord, Show, Read)

data Range = Range {rngLoc :: Loc, start :: RExp, end :: RExp}
  deriving (Eq, Ord, Show, Read)

data LExp
    = Deref   LExp
    -- | Post LExp IncDecOp
    -- | Pre IncDecOp LExp
    | Access  LExp RExp
    | Name    Ident
  deriving (Eq, Ord, Show, Read)

data RExp
    = Or      {reLoc :: Loc, lhs :: RExp, rhs :: RExp}
    | And     {reLoc :: Loc, lhs :: RExp, rhs :: RExp}
    | Not     {reLoc :: Loc, rhs :: RExp}
    | Comp    {reLoc :: Loc, lhs :: RExp, comp :: CompOp, rhs :: RExp}
    | Arith   {reLoc :: Loc, lhs :: RExp, arith :: ArithOp, rhs :: RExp}
    | Sign    {reLoc :: Loc, sgn :: SignOp, rhs :: RExp}
    | RefE    {reLoc :: Loc, rhsL :: LExp}
    | RLExp   {reLoc :: Loc, rhsL :: LExp}
    | ArrList {reLoc :: Loc, rList :: [RExp]}
    | FCall   {reLoc :: Loc, fName :: Ident, rList :: [RExp]}
    | Lit     {reLoc :: Loc, lit :: Literal}
  deriving (Eq, Ord, Show, Read)

data ArithOp 
  = Add
  | Sub
  | Mul
  | Div
  | Mod
  | Pow
  deriving (Eq, Ord, Show, Read)

data AssignOp
    = AssignEq  {asLoc :: Loc}
    | AssignAdd {asLoc :: Loc}
    | AssignSub {asLoc :: Loc}
    | AssignMul {asLoc :: Loc}
    | AssignDiv {asLoc :: Loc}
    | AssignMod {asLoc :: Loc}
    | AssignPow {asLoc :: Loc}
  deriving (Eq, Ord, Show, Read)

data CompOp
    = Lt
    | Leq
    | Eq
    | Neq
    | Geq
    | Gt
  deriving (Eq, Ord, Show, Read)

-- data IncDecOp = Inc | Dec
--   deriving (Eq, Ord, Show, Read)

data SignOp 
  = Pos
  | Neg
  deriving (Eq, Ord, Show, Read)

data Literal
    = LBool Bool
    | LChar Char
    | LInt Integer
    | LReal Double
    | LString String
    | LArr [Literal]
  deriving (Eq, Ord, Show, Read)